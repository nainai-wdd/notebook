================================================
-----------------    JVM      -----------------
================================================

1.内存模型:
	1.程序计数器:Program Counter Register
		当前线程锁执行的字节码的指示器
	
	2.java虚拟机栈: VM Stack
		1.描述java方法的内存模型
		2.每执行一个方法,就同步创建一个栈帧(局部变量,操作数栈,动态链接,方法出口)
		3.栈容量由 -Xss参数来设定
		*请求的栈深度大于虚拟机所允许的深度	:StackOverflowError
		*栈扩展是无法申请到足够的内存		:OutOfMemoryError
		
	3.本地方法栈: Native Method Stack
		1.描述本地方法的内存模型
		2. 同上
	
	4.java堆: java Heap
		1.此内存的唯一目的就是存放对象实例
		2.TLAB:线程私有的分配缓存区
		3.大小由参数 -Xmx 和 -Xms 设定
		*没有完成实例分配,并且堆也无法再扩展时:OutOfMemoryError
		
	5.方法区: Method Area
		1.和堆一样是各个线程共享的内存区域
		2.用于存储已被虚拟机加载的 类型信息, 常量, 静态变量, 即使编译器编译后的代码缓存 等数据
		*方法区无法满足新的内存分配需求时: OutOfMemoryError
		
	6.运行时常量池: Runtime Constant Pool
		是方法区的一部分,用于存放编译期生成的各种字面常量与符号引用
		*常量池无法再申请到内存: OutOfMemoryError
		
	7.直接内存:
		*物理内存不足时:OutOfMemoryError
		
  1.1对象创建
  	1.new 对象名:
  		先进行类加载检查
  	2.分配内存:
  		两种方法,指针碰撞 和 空闲列表
  	3.设置对象头
  	
  	4.调用构造函数
  	
  1.2对象的内存布局:(HotSpot)
  	1.对象头:
  		1.Mark Word:根据虚拟机位数,大小分别为32bit和64bit
  		2.类型指针	:通过类型指针确定对象是哪个类的实例(但并不是所有的虚拟机实现都必须在对象数据上保留类型指针)
  	2.实例数据:
  		1.字段	:(包括父类继承下来的字段,默认存储在子类字段的前面)
  			存储顺序受到虚拟机分配参数(-XX:FieldsAllocationStyle参数)和
  			java源码定义的顺序影响(默认 longs/double,ints,shorts/chars,bytes/booleans,oops)
  				
  	3.对齐填充:
  		对齐填充对象的内存,使其为8bit的整数倍
  		
  1.3对象的访问定位:
  	1.句柄访问:
  	2.直接指针:
======================================================
2.垃圾收集器Garbage Collection（GC）
	回收条件：
	  1.引用计数算法（效率高，但不是java中的主流）
		在对象中添加一个引用计数器，产生引用 +1，引用失效 -1，计数器归零时可回收状态	
		ps：两个对象互相引用时，永远不会被回收
	  2.可达性分析算法
	  	从一系列GC Roots到对象不可达，即为可回收
	  	  ps:枚举根节点时会停止所用用户进程
	  	固定可作为GC Roots的对象：
	  		1.虚拟机栈中引用的对象
	  		2.方法区中静态属性引用的对象
	  		3.方法区中常量引用的对象
	  		4.本地方法栈中JNI（Native方法）引用对象
	  		5.java虚拟机内部的引用
	  		6.所有被同步锁持（synchronized关键字）有的对象
	  		7.反映java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等
	  		8.特点垃圾收集器实现的其他对象
-------------------------------------------------------------
	引用： 	
	  1.强引用：
	  	常规引用
	  2.软引用：
	  	1.在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收
	  	2.创建某引用的软引用
	  		new SoftReference（T reference）	
	  3.软引用：
	  	1.只被弱引用关联的对象只能生存到下一次垃圾收集发生为止
-------------------------------------------------------------
	回收过程：
	   1.第一次标记可回收，若有必要执行finalize方法，则把对象放置在F-Queue中，
	   由一条虚拟机自动建立的，低调度优先的Finalizer线程去执行finalize方法（不承认一定有机会运行）
	   
	   2.一个对象被连续两次标记，则被回收。
	   ps：finalize方法只会执行一次，有机会使被标记对象逃脱回收。
	   ps：finalize是不被推荐使用的，try{}finally{}比他好用
-------------------------------------------------------------
	回收方法区：
	   1.无用类条件(同时满足)
	  	1.该类所有实例都已经被回收了
	  	2.加载该类的类加载器已经被回收了
	  	3.该类对应的java.class对象没有在任何地方呗引用,无法再任何地方通过反射访问该类
	  	
 	   2. 回收常量和堆内存的回收类似
-------------------------------------------------------------
	垃圾收集算法:
	   1.分代收集理论:
	   	把对象分代存储(堆分区)
	   		1.新生代,2.老年代(至少分两个区)
	   	
	   	算法:
	   		1.标记-清除算法:基础算法,速度较快,但会导致内存碎片化
	   		2.标记-复制算法:存活率较低时优先的算法(一般用于新生代)
	   			"半区复制",内存只使用一半,回收时把存活的对象复制到另一半,然后清除原先的内存
	   			"Appel式回收",新生代分为一块较大的Eden空间和两块较小的Survivor空间,需要一个依赖其他内存区域的"逃生门"安全设计
	   		3.标记-整理算法:针对对象存活率高的内存区域(老年代)
	   			让所有存活对象都向内存空间一段移动
	   			好处:内存连续,坏处:速度慢
-------------------------------------------------------------------------
	HotSpot的算法细节实现：
	   1.根节点枚举：
	   	使用一组OopMap数据结构存GC Roots
	   	*类加载动作完成的时候，把对象内什么偏移量上是什么类型的数据计算出来
	   	*在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用
	   	
	   2.安全点：
	   	以“是否让程序长时间执行的特征”为标准进行选定
	   	1.抢先式中断（先停，后判断是否是安全点），
	   	2.主动式中断（先判断是否是安全点，再决定是否停）
	   	
	   *安全区：
	   	在这段代码片段之中，引用关系不会发生变化
	   	ps：安全区代码可以和回收线程并行运行
	   	
	   3.记忆集与卡表：
	   	用记忆集记录跨代引用的GC Roots（非收集区指向收集区的指针集合的抽象数据结构）
	   	*常用实现为 卡表：
	   		此卡页内有跨代引用，则对应卡表的数组元素的值为 1（称此元素变脏），否则为 0
	   		
	   4.写屏障
	   	对引用类型字段赋值的AOP切面（为了维护记忆集）
	   	
	   	*伪共享问题：中央处理器的缓存机制，卡表的维护在高并发下的写操作有概率共享同一个缓存行，导致性能降低（写回，无效化，或者同步）	
	   		解决方式：采取有条件的的写屏障，即只有当卡表元素未被标记过时才将其标记为变脏
	   	
	   5.并发的可达性分析：
	   	标记阶段的并行操作可行性（枚举GC roots之后）
	   	*利用节点遍历时的三种状态讨论并发下的问题（未访问，已访问，完全访问）
	   	
	   	同时满足以下两点，会导致对象消失：
	   		1.赋值器插入了一条或多条从黑色对象到白色对象的新引用
	   		2.赋值器删除了全部从灰色对象到该白色对象的直接或者间接引用
	   	解决方法：
	   		1.增量更新：当情况 1 发生时，记录那个黑色对象，等待并发扫描结束，以它们为根重新扫描一次
	   		2.原始快照：灰色对象删除白色对象的引用时，记录灰色对象，并发扫描结束后，以它们为根重新扫描一次
	-------------------------------------------------------------
	   6.经典的垃圾收集器：
	   	1.Serial收集器：
	   		1.单线程
	   		2.新生代 复制算法，老年代 整理算法
	   		3.最高的单线程收集效率，额外内存消耗最小
	   		
	   		测试结果:
	   			1.新生区回收时,同期的存活对象内存总和大于survivor的一半,则这一期对象直接晋升到老年区
	   			2.空间分配担保策略:
	   				回收时,若老年区最大可用的连续空间小于新生代所有对象的总空间,则视为冒险行为1,
	   									  若小于历次晋升的平均空间,则视为冒险行为2
	   				若冒险行为1,2同时存在(1&&2),则进行Full GC, 否则进行Minor GC (JDK6 updata24之后)
	   	2.ParNew收集器：
	   		1.Serial的多线程版本
	   		2.能够与CMS收集器配合工作（激活CMS后的默认新生代收集器，且JDK9后只能和CMS搭配）
	   		
	   	3.Parallel Scavenge收集器：
	   		1.是一款新生代收集器，基于标记——复制算法
	   		2.可控的吞吐量（Throughput）
	   		  吞吐量 = 运行 用户代码时间 / （用户时间 + 垃圾收集时间）
	   			1.垃圾收集器最大停顿时间：-XX：MaxGCPauseMillis
	   				牺牲新生代大小和吞吐量实现更小的最大停顿时间
	   			2.直接设置吞吐量大小	：-XX：GCTimeRatio
	   			3.自适应调节策略开关	：-XX：PretenureSizeThreshold
	   				自动调节新生代大小(-Xmn), Eden与Survivor区的比例(-XX:SurvivorRatio),
	   					大对象晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数.
	   				Ps:虚拟机动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量
	   		
	   	4.Serial Old收集器：
	   		Serial的老年代版本，标记整理算法
	   		用途：CMS收集器发生失败时的后备预案
	   			
	   	5.Parallel Old收集器：
	   		Parallel Scavenge的老年代版本，标记整理算法
	   		
	   	-------------------------------------------------------------	
	   	6.CMS收集器：
	   		1.获取最短回收停顿时间为目标的收集器
	   			B/S系统的服务端上，关注服务的响应速度，希望系统停顿时间尽可能短，给用户带来良好的体验
	   			
	   		2.基于标记-清除算法(增量更新)
	   		工作过程:
	   			1.初始标记:(stop world)
	   			2.并发标记:与用户线程并发
	   			3.重新标记(stop world)
	   				增量更新
	   			4.并发清除:与用户线程并发
	   		ps:
	   			1.无法清除浮动垃圾
	   			2.并发失败时,临时启动Serial Old收集器
	   			3.产生大量空间碎片(多次清理之后应当进行碎片整理)
	   			
	   	-------------------------------------------------------------		
	   	7.Garbage First(G1)收集器:
	   		1.主要面对服务器端应用(以短停顿时间为目标,横向对比CMS)
	   		2.把连续的java堆划分为多个大小相等的独立区域(Region),和特殊的Humongous区域存放大对象(超过0.5个Region),ps: Region大小设置(-XX:G1HeapRegionSize),取值1~32MB,2的整数次幂
	   		3.跟踪各个Region里面垃圾堆积的"价值"大小,在后台维护一个优先列表,每次根据设定允许的收集停顿时间(使用参数-XX:MaxGCPauseMillis指定,默认200ms),优先处理回收价值最大的那些Region。
	   		
	   		4.局部基于标记-复制算法,整体基于标记整理算法
	   		工作过程:
	   			1.初始标记:(stop world)
	   			2.并发标记:并行
	   			3.最终标记:(stop world)
	   				原始快照
	   			4.筛选回收:(stop world)
	   				1.根据期望的停顿时间制定回收计划
	   				2.把决定回收的那些Region中存活对象复制到空的Region中,在清理掉整个旧Region
	   				
	   		5.若是回收跟不上分配,垃圾慢慢堆积,最终占满引发Full GC
	   		
	   		6.维护记忆集十分繁琐,并且额外占用很大的堆内存(记忆集和其他内存消耗).
	   		
	   	PS:G1 在大内存应用优于 CMS(通常平衡点6GB左右), 同时G1进步空间大
	   	
		-------------------------------------------------------------
	   	8.Shenandoah收集器
	   		1.同G1一样使用Region,部分回收
	  		2.用连接矩阵的全局数据结构来记录跨Region的引用关系
	  		3.支持并发整理算法
	  		
	  		工作过程:
	  		   1.并发标记
	  			1.初始化标记:(stop world)
	  			2.并发标记	:
	  			3.最终标记	:(stop world)
	  		   2.并发回收
	  			1.并发清理	:
	  			2.并发回收	:
	  				复制存活的对象到新的Region中
	  		   3.并发引用更新:
	  		   	1.初始引用更新:(stop world)
	  		   		只是为了建立线程集合点,确保之前的任务全部完成
	  		   	2.并发引用更新:
	  		   		按内存物理地址线性搜索出引用类型,把旧值改新值
	  		   	3.最终引用更新:(stop world)
	  		   		修正GC Roots中的引用
	  		   	4.并发清理:
	  		   		
	  		PS:并发回收实现原理:
	  			1.转发指针
	  			2.读屏障
	   		
	   		4.效果:
	   			1.停顿时间很短(相较与上文的其他收集器)
	   			2.吞吐量明显下降
	   			
	   	-------------------------------------------------------------		
	   	9.ZGC收集器:(JDK11加入,实验性质)
	   		1.使用3中不同大小的Region,但是不分区,全面回收内存
	   			1.不用使用写屏障
	   		2.使用染色指针技术,实现并发回收
	   			1.在linux和window平台利用多种映射实现
	   			2."指针自愈"
	   				1.Region在更新时可以快速被清理
	   				2.可以不用专门实现引用更新
	   			3.不用使用写屏障
	   			4.可扩展,未来可以用新的用途
	   		3.支持"NUMA-Aware"
	   			多核心环境下吞吐量高
	   		
	   		4.效果:
	   			1.目前最好的收集器,超短的停顿时间(10ms),和不错的吞吐量
	   			2.有很好的发展前景
	   	
		-------------------------------------------------------------
		* Epsilon收集器:(不能回收垃圾的收集器)
			1.仅仅起到 自动内存管理子系统 的作用
			2.是垃圾收集器的最小模式
			3.微服务,无服务,等短时间运行的应用上使用
			
	----------------------------------------------------------------------
	垃圾收集器的选择:
		1.程序的关注点:
			要高吞吐还是低延时
		2.运行应用的基础设施如何:
			适配环境
		3.使用JDK的发行商,版本号:
	----------------------------------------------------------------------
	虚拟机垃圾收集器日志:
	   设置参数:
		-Xlog[:[selector][:[output][:[decorators][:output-options]]]]	
			
	   常用案例:
	   	1.查看GC基本信息:(JDK9后放在后面)
	   		-XX:+PrintGC
	   		-Xlog:Gc
		2.查看GC详细信息:
			-XX:+PrintGCDetails
			-Xlog:gc*
		3.查看GC前后的堆,方法区可用容量变化
			-XX:+PrintHeapAtGc
			-Xlog:gc+heap=debug
		4.查看GC过程中用户线程并发时间以及停顿的时间
			-XX:+PrintGCApplicationConcurrentTime
			-Xlog:safepoint
		5.查看收集器Ergonomics机制自动调节的相关信息
			-XX:+PrintAdaptiveSizePolicy
			-Xlog:gc+ergo*=trace
		6.查看熬过收集器后剩余对象的年龄分布信息
			-XX:+PrintTenuringDistribution
			-Xlog:gc+age=true