===============================================
---------------------spring--------------------
===============================================
优势:
	1.方便解耦,简化开发
	2.AOP编程的支持
	3.声明式事务的支持
	4.方便程序的测试
	5.方便集成各种优秀的框架
	6.降低javaEE api的使用难度
	7.java源码是经典学习范例

----------------------------------------------IOC:Inversion Of Control	控制反转
	*把创建对象的权利交给框架,削减耦合
	1.不直接new对象,通过new工厂,让工厂给出对象
	2.工厂也不直接new对象,利用反射,得到类的实例对象

----------------------------------------------
使用前的准备:
	1.准备spring的开发包
	2.创建业务层接口和实现类
	3.创建持久层接口和实现类
	4.配置xml
	 1.导入jar包
	 2.创建xml文件(类(资源)的根路径下)
	 3.在配置文件中配置service和dao(依赖注入)
	5.获取spring容器(指定xml路径)
	6.根据bean的id获取对象	getBean("id")
----------------------------------------------
spring核心容器的两个接口:
	*ApplicationContext:单例对象使用	采用此接口
		构建核心容器时,创建对象的策略是立即加载
	*BeanFactory:多例对象使用
		构建核心容器时,创建对象的策略是延时加载
----------------------------------------------
获取容器:
	new ClassPathXMLApplicationContext(bean.xml)
----------------------------------------------
bean标签
	作用：
		用于配置对象让 spring 来创建的。
		默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。

	属性:
	 *id:给对象在容器中提供唯一标识
	 *class:指定类的全限定类名.用于反射创建对象.默认情况下调用无参构造函数。

	 *scope属性:指定bean的作用范围
		取值:
		*singleton:单例(默认值)
		*prototype:多例
		*request:web项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.
		*session:同上,session域中
		*global:作用于集群环境的会话范围
	------------------------------------------
# bean的作用范围和生命周期
	单例对象:scope="singleton"
		*一个应用只有一个对象的实例。它的作用范围就是整个引用。
		*生命周期：同容器同生同死

	多例对象：scope="prototype"
		*每次访问对象时，都会重新创建对象实例。
		*生命周期：随容器创建而生,直到被java垃圾回收器回收(与容器状态无关)

----------------------------------------------
实例化bean的三种方式
	-------------------------------------
	1.根据默认无参构造函数来创建类对象
	<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"/>

	-------------------------------------
	2.spring管理静态工厂,使用静态工厂的方法创建
		0.模拟一个静态工厂，创建业务层实现类
	public class StaticFactory {
		public static IAccountService createAccountService(){
			return new AccountServiceImpl();
		}
	}
		1.在bean标签中使用工厂的静态方法
		<bean id="accountService"
 class="com.itheima.factory.StaticFactory"
 factory-method="createAccountService"></bean>

*使用工厂类中的静态方法创建对象,并存入spring容器
	id 属性：指定 bean 的 id，用于从容器中获取
	class 属性：指定静态工厂的全限定类名
	factory-method 属性：指定生产对象的静态方法

	----------------------------------
	3.spring管理实例工厂,使用实例工厂的方法创建对象
		0.模拟一个实例工厂，创建业务层实现类
	public class InstanceFactory {
		public IAccountService createAccountService(){
			return new AccountServiceImpl();
		}
	}
		1.在<bean>标签中实例工厂,再使用工厂的bean来调用里面的方法
	<bean id="instancFactory" class="com.itheima.factory.InstanceFactory"></bean>
	<bean id="accountService"
 factory-bean="instancFactory"
 factory-method="createAccountService"></bean>

----------------------------------------------
依赖注入
	把依赖注入后,让spring自动完成这些有依赖的过程
  	--------------------------------------
 # 构造函数注入:
	用类中的构造函数，给成员变量赋值。
	  *要求：
		类中需要提供一个对应参数列表的构造函数。
	  *涉及的标签：
	 	constructor-arg
		*属性：
	  	index:指定参数在构造函数参数列表的索引位置
	  	type:指定参数在构造函数中的数据类型
		name:指定参数在构造函数中的名称(常用)
=======上面三个都是找给谁赋值，下面两个指的是赋什么值的
		value:它能赋的值是基本数据类型和 String 类型
		ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean

	--------------------------------------
 # set 方法注入:
	通过配置文件给 bean中的属性传值：使用 set 方法的方式
	涉及的标签：
	  property
	属性：
	  name：找的是类中 set 方法后面的部分
	  ref：给属性赋值是其他 bean 类型的
	  value：给属性赋值是基本数据类型和 string 类型的
	*实际开发中，此种方式用的较多。

	--------------------------------------
 # p名称空间注入数据(本质set)
	此种方式是通过在 xml中导入 p 名称空间，使用 p:propertyName 来注入数据，
	

	--------------------------------------
 # 注入集合属性(set)
	<!-- 注入集合数据
	List 结构的：	//<list><value>
		array,list,set
	Map 结构的	 //<map><entry key= value=>
		map,entry,props,prop
	-->

----------------------------------------------

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd">

<!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中
 id 属性：对象的唯一标识。
 class 属性：指定要创建对象的全限定类名
-->
<!-- 配置 service -->
<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
</bean>
<!-- 配置 dao -->
<bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl">
</bean>

===================================================

注解方式:
//注解在类上------------------------------
 # 用于创建对象:	相当于<bean id="" class="">
	@Component	
	@Conroller :用于表现层
	@Service	:用于业务层
	@Repository:用于持久层
 *如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写,以上4个注解本质相同,

 # 用于改变作用范围:相当于：<bean  scope="">
	@Scope
	   value：指定范围的值。
		singleton
		prototype
 		request
 		session
 		globalsession

 # 关于配置类
	 @Configuration:
		用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用
AnnotationApplicationContext

	@ComponentScan:
		用于指定 spring 在初始化容器时要扫描的包。

	@PropertySource
		value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:

	@Import:用于导如其他配置类
		value[]：用于指定其他配置类的字节码。

 		-----------------------
  * 关于Spring整合junit
	1.导入整合 junit 的必备 jar
	2.@RunWith 注解替换原有运行器
	3.@ContextConfiguration指定配置文件(类)的位置
	4.用@Autowired给变量注入数据
//注解在属性上---------------------------------
 # 用于注入数据:	可以使用el表达式
	相当于：<property name="" v/r=""> 
	@Autowired:自动注入,使用要注入的对象变量名称作为bean的 id
	@Qualifier:在自动注入的基础上指定id
		value:指定 bean的 id。
	@Resource:直接按照Bean的id注入。
		name：指定 bean 的 id。
	@Value:注入基本数据类型和 String 类型数据的
		value：用于指定值

//注解在方法上----------------------------------
	@Bean:
		name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。
	@PostConstruct:	用于指定初始化方法。
	@PreDestroy:	用于指定销毁方法。

