=============================================
------------------java SE--------------------
==============================================
静态数据的初始化:
	1.被类加载器加载时(只会加载一次) 
		*按顺序执行静态代码(存在方法区)
//当第一次使用这个类时,会先自动把这个类加载进方法区

----------------------------------------------
方法使用可变参数时,传入的参数会自动把参数填充到数组中

-----------------------------------------------
访问权限修饰符
	*何处调用,何处判断
0.默认:
	包访问权限
1.public:
	访问不受限的
2.private:
	只允许在类内部访问
3.protected:
	包内可见的，并且对子类可见；

	*类的访问权限只能是 public 或者 默认
---------------------------------------------------
final关键字
	1.作用在成员变量上
		成员变量初始化时必须赋值,且这个值不允许改变
	2.作用在方法上( private 方法自动属于 final )
		继承时不能被覆盖
	3.作用在类上
		类不能被继承

--------------------------------------------------
子类的构造器:
	*有显式this()调用的构造器就会抑制掉该构造器里隐式的super()调用；
	*没有显式this()调用的构造器则会得到隐式的super()调用。
	ps:一连串this()的最后一个必然不再会在开头有this()调用，而这个开头没有this()调用的构造器就会得到编译器给隐式合成的super()调用
	

	创建子类时会按继承层次逐渐向上链接,以使每个基类的构造器都能得到调用
	*一个子类对象的实例会包含其所有基类所声明的字段，外加自己新声明的字段。

--------------------------------------------------
抽象类:单一继承
接口:多重继承
	*接口中的域隐式地是static和final的

--------------------------------------------------
内部类:
	1.内部类可以访问其所在类的所有属性
	2.使用其所在类的类名.this 来产生所在类的引用
	3.局部变量传递给匿名内部类是基于构造器传参的.不能在匿名内部类中修改外部局部变量

	**通过内部类提供闭包**
	**通过内部类实现多重继承**

--------------------------------------------------
容器类:
  *描述功能型的接口:
	0.Stack(本应该是接口,但它是实现类)
	其实现类不好用, 需要用时用Queue代替

	1.Queue 队列
	2.Set: 无映射符号表
	3.Map: 映射符号表

  *描述数据结构的接口:
	1.List: 序列表
	2.Map: 符号表

  ##常用实现类:		实现的功能接口
	1.ArrayList: 	Queue  DeQueue
	2.LinkedList	Queue  Dequeue
	3.PriorityQueue	Queue
	3.HashSet		Set
	4.HashMap		Map
	5.LinkedHashMap Map
	6.TreMap		Map
	
 #详解:
  ArrayList:自动扩容的数组
  	注意事项:
  		按索引遍历删除指定元素时,数组会发生变化。会导致漏删。
  		可以采用，倒序遍历。或者迭代器中使用remove方法
  	 
  LinkedList：双向链表
  	注意事项:
  		1.可以当做Queue和Stack使用(ps: Stack不是接口)
  		2.尽量不要通过索引遍历
  		
  PriorityQueue:优先队列
  	注意事项:
  		1.维护了一个数组实现的最小堆
  		
  HashSet,LinkedHashSet,TreSet:Set
  	注意事项:
  		与同名的Map类似
    	
  HashMap:
  	注意事项:
  		0.维护了一个拉链法处理冲突的散列表.(无序)
  		1.默认LOADING_FACTORY = 0.75f
  		2.数组大小 m 为 2^x。（原因：利用hash值计算索引时可以利用位运算，效率高）
  		3.计算hash值时,把key的hash值的前16位和后16位做位与,(原因:数组大小为 2 的整数次幂,利用哈希计算索引时,只		有低位有影响)
  		4.拉链法中的单链表在节点大于8时转换为红黑树,节点小于6时变回单链表
  		5.resize()方法巧妙利用 hash & m == 0 来判断扩容后节点所对应的节点是否改变
  		6.真的用了好多位运算。佩服
  
  LinkedHashMap:有序的HashMap
  	注意事项:
  		1.继承HashMap
  		2.利用给Node节点加上了before, after。从而实现有序遍历
  
  TreMap：红黑树Map
  	注意事项：
  		1.红黑树,元素必须可比较
  		2.时间复杂度,查找 < 插入 < 删除 约等于 lg(n)
  		3.利用节点旋转变化,和颜色翻转变化,不会影响等效树高.来维护树的等效平衡
  		4.最差情况,树高等于2lg(n)
--------------------------------------------------
字符串:

	String:		不带缓存区
	StringBuffer:	线程安全
	StringBuilder:	不是线程安全的
	
--------------------------------------------------
正则表达式（pattern类）
 *字符类
	.：	任意字符
	//d：	整数字符
	//w: 	单词字符
	//s:	空白符（空格，tab，换行，换页和回车）
		**大写视其为非**

	.：	任意字符
	[ab]:	ab间任意一个
	[^ab]:除了ab之外的任意字符
	[a-z]:a至z中的任意
	[R1&&R2]:R1和R2的交集
	
 *边界匹配器 
	^ 行的开头 
	$ 行的结尾 
	\b 单词边界 
	\B 非单词边界 
	\A 输入的开头 
	\G 上一个匹配的结尾 
	\Z 输入的结尾，仅用于最后的结束符（如果有的话） 
	\z 输入的结尾 

 *量词
	+：	1次或多次匹配前面的字符
	*:	零次或者多次匹配前面的字符
	?:	零次或者1次匹配前面的字符

	*默认贪婪型,尽可能长的匹配
	*量词后加 ? 为勉强型:
		匹配满足模式所最少的的字符串
	*量词后加 + 为占有型:
		匹配时不保存中间状态

Pattern对象:
	*Pattern.complie(String regex)由静态方法得到Pattern对象
	*Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.
	.split(CharSequence input):分割字符串
	.matcher(CharSequence input):得到Matcher对象

Matcher对象
	.matches():	对整个字符串进行匹配
	.lookingAt():	对前面的字符串进行匹配
	.find():		对字符串进行匹配
	
	当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息. 
	start()返回匹配到的子字符串在字符串中的索引位置. 
	end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. 
	group()返回匹配到的子字符串

例子:
  while(m.find()) { 
     System.out.println(m.group()); 
  } 

--------------------------------------------------
代理:
   1.静态代理:
	创建一个直接引用原对象的代理对象
   2.动态代理:
	在运行时创建代理对象

	1.JDK动态代理:
	  特点:
		1.动态创建 包含原对象引用的代理对象
		2.原对象必须实现接口
		3.JDK直接支持
	  步骤:
		1.获取信息
			1.类加载器
			2.代理对象所实现的接口
		2.编写处理器 InvocationHandler
			*需要原对象的实例
		3.利用Proxy.newProxyInstance创建代理对象实例
	  例子:
Sale proxy = (Sale)Proxy.newProxyInstance(Computer.class.getClassLoader(), 				Computer.class.getInterfaces(), new InvocationHandler() {
           Object computer = new Computer();
           @Override
           public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			return method.invoke(computer, args);
		}});

	2.CGLIB动态代理:
	   特点:
		0.(需要导入jar包)
		1.动态创建 继承了原对象的代理对象
		2.无需实现接口
		3.高性能
	   步骤:
		1.创建用于拦截回调的类(继承MethodInterceptor)
		2.创建Enhancer设置拦截对象,设置回调的类(传入1.对象),设置回调策略(编写类,继承CallbackFilter,传入对象)
		3.利用Enhancer.create()创建代理对象
		
	  **可以使用工厂模式来代理接口

--------------------------------------------------
空对象模式,可以利用代理实现
==================================================================================
*本地字符流默认JBK编码



函数式接口(只有一个抽象方法)	        					抽象方法
	Function<T, R>	T：入参类型，	R：出参类型		R apply(T t)
	Suppiler<R>     没有入参       	R：出参类型；		R get();
	Consumer <T>	T：入参类型；	没有出参      		void accept(T t)
	Predicate <T>   T：入参类型；	出参类型是Boolean	boolean text（T t）

Stream流获取常用方法：
	Collection  集合通过stream方法获取流
	Stream接口的静态方法of可以获取数组对应的流



Stream流常用方法：  Stream流属于管道流，只能被消费一次，一个流只能用一次
	void forEach（Consumer <? super T>  ）;  遍历	是终结方法.使用后流不能再次使用。
	stream<T> filter(Predicate <? super T>  );  筛选
	<R>Stream <R> map(Function<?  super T,? super  R>   );  映射
	Stream<T> limit(long max)；  截取前几
	Stream<T> skip(long n);  跳过前几
	long count();  计数

方法的引用：			等效lambda表达式
	对象名：成员方法		(参数)->对象名.成员方法(参数)
	   类名：静态成员方法		(参数)->类名.静态成员方法(参数)
  	 super：父类成员方法		(参数)->super.父类成员方法(参数)
	    this：本类成员方法		(参数)->this.本类成员方法(参数)
	构造器
	   类名：new		(参数)->new 类名(参数)
	 类名[]：new		(参数)->new 类名[参数](参数)

反射：
	
	获取 类对象的方法：
	1.Class.forName("全类名")	：将字节码文件加载进内存，返回Class对象
		*多用于配置文件，将类名定义在配置文件中。读取文件加载类
	2.类名.class		：通过类名的属性class获取
		*多用于参数的传递
	3.对象.getClass		：getClass（）方法在object类中定义者
		*多用于对象的获取字节码的方式

	同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次.不论通过哪一种方式获取的Class对象都是同一个
	
	class对象功能：
		1.获取成员变量们：
		   *Field[] getFilter()			：  获取所有public修饰的成员变量
		   *Field getFilter(String name)		：  获取指定名称的public修饰的成员变量
		
		   *Field[] getDeclaredFilter()		：获取所有的成员变量
		   *Field getDeclaredFilter(String name)	：获取指定名称的成员变量
		
		2.获取构造方法们		Class<?>... parameterTypes//例子：方法参数为int,那么此处参数为int.class
		   *Constructor<?>[] getConstructors()
		   *Constructor<T> getConstructors(Class<?>... parameterTypes)   
		   
		   *Constructor<?>[] getDeclaredConstructors()
		   *Constructor<T> getDeclaredConstructors(Class<?>... parameterTypes)
		3.获取成员方法们
		   *Method[] getMethod()
		   *Method getMethod(String name,Class<?>... parameterTypes)

		   *Method[] getDeclaredMethod()
		   *Method getDeclaredMethod(String name,Class<?>... parameterTypes)
		4.获取类名
		   *String getName()
		5.获取类加载器
		   *ClassLoader getClassLoader()
		6.获取注解
		   *<A extends Annotation>A getAnnotation(Class<A> annotationClass)//返回该注解(接口)的子类实现对象,抽象方法用(return 属性值)重写

	*Field：成员变量
	       *操作：
		1.设置值
		   *void set(Object obj,Object value)
		2.获取值
		   *get(Object obj)

		3.忽略访问权限修饰符的安全检查
		   *setAccessible(true)：暴力反射	
	
	*Constructor：构造方法
	       *创建对象：
		*T newInstance(object... initargs)
		*setAccessible(true)：暴力反射//忽略访问权限修饰符的安全检查

	*Method：成员方法
	       *执行方法：
		*Object invoke(Object obj,Object...args)
		*setAccessible(true)：暴力反射//忽略此访问权限修饰符的安全检查

	*ClassLoader类加载器
	       *获取class目录下的配置文件字节流：
		*Inputstream getResourceAsStream(String name)

注解：
	*作用分类：
	       1.编写文档：[生成doc文档]
	       2.代码分析：[使用反射]
	       3.编译检查：[例如Override]

	*JDK中预定的一些注解：
	       *@Override	：检测被该注解标注的方法是否是继承自父类中(接口)的
	       *@Deprecated	：将该注解标注的内容,已过时
	       *@SuppressWarnings：压制警告

	*自定义注解
	       *格式：
		元注解(描述注解的注解)
		public @intterface 注解名称{
			属性列表;(实际上是抽象方法)
}
	       *本质：注解本质上就是一个接口,该接口默认继承Annotation接口
		*public interface 注解名称 extends java.lang.annotation.Annotation{}

	       *属性：接口中的抽象方法
		*要求：
		     1.属性的返回值有下列取值
			*基本数据类型
			*String
			*枚举
			*注解
			*以上类型的数组

		     2.定义了属性的注解,在使用时要给属性赋值
			1.如果定义属性时,使用default关键字给属性默认初始化值,则使用注解时,可以不进行属性的赋值.
			2.如果只有一个属性需要赋值,并且属性的名称是value.则value可以省略,直接定义值即可
			3.数组赋值时,使用{}包裹。如果数组只有一个元素，则{}可以省略。
	       *元注解：用于描述注解的注解
		*@Target：描述注解能够作用的位置
		     *ElementType取值：
			*TYPE：可以作用于类上
			*METHOD：可以作用于方法上
			*FIELD：可以作用于成员变量上
		*@Retention:描述注解被保留的阶段
		     *@Retention(RetentionPolicy.SOURCE):当前被描述的注解,不会保留到class字节码文件中
		     *@Retention(RetentionPolicy.CLASS):当前被描述的注解,会保留到class字节码文件中.不会被JVM读取到
		     *@Retention(RetentionPolicy.RUNTIME):当前被描述的注解,会保留到class字节码文件中.并被JVM读取到
		*@Documented：描述注解是否被抽取到api文档中
		*@Inherit：描述注解是否被子类继承

	*在程序中(解析)注解：获取注解中定义的属性值
	       1.获取注解定义的位置的对象（Class，Method，Field）
	       2.获取指定的注解
		*getAnnotation（class）//
		//其实就是在内存中生成了一个该注解接口的子类实现对象，抽象方法用（return 属性值）重写
	       3.调用注解中的抽象方法获取配置的属性值
         小结：
	1.大多时候我们用注解，很少自定义注解
	2.注解给谁用？
	         1.编译器
	         2.给解析程序用
	3.注解不是程序的一部分，可以理解为注解就是一个标签
