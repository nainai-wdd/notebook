  #mybatis:
     快速入门(maven工程里)
	1.在pom.xml文件中添加mybatis坐标
	2.编写传递数据的实体类(domin)
	3.编写dao接口,写方法
	4.编写dao接口的映射文件.xml
	<mapper namespace="接口的全类名">	//命名空间,忘了什么意思
	   <关键字 id=""(对应接口中的方法)
		  parameterType="''"(参数类型全类名)	
		  resultType="" (封装类型全类名)
		SQL语句<关键字/>

		*使用ognl表达式:#{对象.对象}
		接受简单值或者pojo属性值
	   </关键字>
	</mapper>
	5.编写SQLMapConfig.xml配置文件
--------------------------------------------------------------------
     使用:
	//1.读取配置文件
	InputStream is = Resources.getResourceAsStream("SqlMapConfig.xml");

	//2.创建 SqlSessionFactory 的构建者对象
	SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();

	//3.使用构建者创建工厂对象 SqlSessionFactory
	SqlSessionFactory factory = builder.build(is);

	//4.使用 SqlSessionFactory 生产 SqlSession 对象
	SqlSession session = factory.openSession();

	//5.使用 SqlSession 创建 dao 接口的代理对象
	IUserDao userDao = session.getMapper(IUserDao.class);

	//6.使用代理对象执行查询所有方法
	List<User> users = userDao.findAll();
	for(User user : users) {
	System.out.println(user);
	}

	//7.释放资源
	session.close();
	is.close();
	
	//*注意:模糊查询的&&在封装入参的时候加(防止SQL注入)
--------------------------------------------------------------------	
   parameterType配置参数:
	*mybaits 在加载时已经把常用的数据类型注册了别名，
	从而我们在使用时可以不写包名，而我们的是实体类并
	没有注册别名，所以必须写全限定类名。

	自定义别名：
	在 SqlMapConfig.xml 中配置：
	<typeAliases>
	  <!-- 单个别名定义 --> <typeAlias alias="user" type="com.itheima.domain.User"/>
	  <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --> <package   name="com.itheima.domain"/>
	  <package name="其它包"/>
	</typeAliases>


     OGNL表达式：
	Object Graphic Navigation Language
	对象	图	导航	   语言
	
	它是通过对象的取值方法来获取数据。在写法上把get给省略了。
	比如：我们获取用户的名称
		类中的写法：user.getUsername();
		OGNL表达式写法：user.username
	*若在parameterType中已经提供了属性所属的类，所以此时不需要写对象名

   resultType 配置结果类型
	* <resultMap> 标签可以建立查询的列名和实体类的属性名称
	不一致时建立对应关系。从而实现封装。
	
	type 属性：指定实体类的全限定类名
	id 属性：给定一个唯一标识，是给查询 select 标签引用用的。
	
      <resultMap type="实体类全类名" id="引用名称">

	<id  	property="userId"  	column="id"/>  //映射属性
	<result property="userName"	column="username"/>
	<result property="userSex"	column="sex"/>

	<association property="user" javaType="user"> //映射对象
           <id property="id" column="id"></id>
	   <result column="username" property="username"></result>
           ...
	</association>

	<collection property="accounts" ofType="account">//映射集合
            <id column="aid" property="id"></id>
            <result column="uid" property="uid"></result>
            ...
        </collection>
        
      </resultMap>

	id 标签:指定主键字段
	result 标签：用于指定非主键字段

	*property 属性：用于指定实体类属性名称
	*column 属性：用于指定数据库列名
	
----------------------------------------------------------------------

   SqlMapConfig.xml配置文件:

	-properties（属性）
	   --property

	   *两种方法:
	   	1.在文件里直接写<property name="" value="">

	   	2.在classpath 下定义 db.properties 文件
	    	  然后在xml里配置<properties resource/url = "">

			*resource配置,要求配置文件必须在类路径下
			*url:协议+主机+端口+uri


	-settings（全局配置参数）
	   --setting


	-typeAliases（配置类型别名）
	   --typeAliase
	   --package
	例如:
	<typeAliases>
       	 <package name="com.itheima.domain"></package>
    	</typeAliases>


	-typeHandlers（类型处理器）
	-objectFactory（对象工厂）
	-plugins（插件）



	-environments（环境集合属性对象）	mysql
	  --environment（环境子属性对象）	mysql
	     ---transactionManager（事务管理）	JDBC
	     ---dataSource（数据源）		
	
	-mappers（映射器）
	  --mapper
	  --package

------------------------------------------------------------------
   mappers（映射器）
	<mapper resource=" " />
	    使用相对于类路径的资源
	    如：<mapper resource="com/itheima/dao/IUserDao.xml" />

	<mapper class=" " />
	    使用 mapper 接口类路径
	    如：<mapper class="com.itheima.dao.UserDao"/>
	    注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。 

	<package name=""/>
	    注册指定包下的所有 mapper 接口
	    如：<package name="cn.itcast.mybatis.mapper"/>
	    注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。

------------------------------------------------------------------ 

-----------------------------------------------------------------------

  连接池分类:
	UNPOOLED:不适用连接池
	POOLED:连接池
	JNDI

------------------------------------------------------------------

  事务控制
	在 CUD 操作中，必须通过 sqlSession.commit()方法来执行提交操作。
	
	若要自动提交,在创建 SqlSession 对象时传入参数true
		session = factory.openSession(true);

------------------------------------------------------------------

  动态SQL
	<if test="boolean类型值"></if>标签

	<where></where>标签:标签体内有内容则自动加where

	<foreach collection="ids" open="id in ( " close=")" item="uid" 
	separator=",">
		#{uid}
	</foreach>
------------------------------------------------------------------

  简化编写的SQL片段
	<!-- 抽取重复的语句代码片段 -->
	   <sql id="defaultSql">
		select * from user
	    </sql>

	<!-- 配置查询所有操作 -->
	   <select id="findAll" resultType="user">
		<include refid="defaultSql"></include>
	   </select>

------------------------------------------------------------------
  JNDI
	mocat模仿windows系统的注册表,键值对形式.

------------------------------------------------------------------



-------------------------------------------------------------------
备忘
	1.flushCache将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：true（对于 insert、update 和 delete 语句）。
-----------------------------------------------------
	2.
selectKey 元素的属性
属性
描述
keyProperty
selectKey 语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 
keyColumn
匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 
resultType
结果的类型。MyBatis 通常可以推断出来，但是为了更加精确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的 Object 或一个 Map。 
order
这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它会首先生成主键，设置 keyProperty 然后执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。 
statementType
与前面相同，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 语句的映射类型，分别代表 PreparedStatement 和 CallableStatement 类型。 
-------------------------------------------------重要到爆炸
3结果映射（resultMap）
constructor - 用于在实例化类时，注入结果到构造方法中 
idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能
arg - 将被注入到构造方法的一个普通结果
id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能
result – 注入到字段或 JavaBean 属性的普通结果
association – 一个复杂类型的关联；许多结果将包装成这种类型 
嵌套结果映射 – 关联本身可以是一个 resultMap 元素，或者从别处引用一个
collection – 一个复杂类型的集合 
嵌套结果映射 – 集合本身可以是一个 resultMap 元素，或者从别处引用一个
discriminator – 使用结果值来决定使用哪个 resultMap 
case – 基于某些值的结果映射 
嵌套结果映射 – case 本身可以是一个 resultMap 元素，因此可以具有相同的结构和元素，或者从别处引用一个


ResultMap 的属性列表
	id	当前命名空间中的一个唯一标识，用于标识一个结果映射。
	type	类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。

----------------------------------------------------------------	
关联元素
<associate>

columnPrefix
当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。



